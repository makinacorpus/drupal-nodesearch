<?php
/**
 * Yes, this is a module.
 *
 * Et oui, ce module est moche. Mais il marche.
 */

require_once __DIR__.'/nodesearch.element.inc';
require_once __DIR__.'/nodesearch.field.inc';

/**
 * Implements hook_menu().
 */
function nodesearch_menu() {
  return [
    'ajax/node/search' => [
      'page callback'   => 'nodesearch_page_endpoint',
      'page arguments'  => [],
      'access callback' => true,
      'type'            => MENU_CALLBACK,
    ],
    'node/search/test' => [
      'page callback'   => 'drupal_get_form',
      'page arguments'  => ['nodesearch_page_test_form'],
      'access callback' => true,
      'type'            => MENU_CALLBACK,
    ],
  ];
}

/**
 * Implements hook_library().
 */
function nodesearch_library() {
  $libraries = [];

  $embedReact = variable_get('nodesearch_react_enable', true) && !module_exists('react');
  if (null === ($useDev = variable_get('nodesearch_dev_mode', null))) {
    $useDev = (0 < variable_get('error_log'));
  }

  if ($embedReact) {
    if ($useDev) {
      $libraries['react'] = [
        'title' => 'React',
        'website' => 'https://reactjs.org/',
        'version' => '16.*',
        'js' => [
          'https://unpkg.com/react@16/umd/react.production.min.js' => ['external' => true],
          'https://unpkg.com/react-dom@16/umd/react-dom.production.min.js' => ['external' => true],
        ],
      ];
    } else{
      $libraries['react'] = [
        'title' => 'React',
        'website' => 'https://reactjs.org/',
        'version' => '16.*',
        'js' => [
          'https://unpkg.com/react@16/umd/react.development.js' => ['external' => true],
          'https://unpkg.com/react-dom@16/umd/react-dom.development.js' => ['external' => true],
        ],
      ];
    }
  }

  $path = drupal_get_path('module', 'nodesearch');

  $libraries['nodesearch'] = [
    'title' => 'Node search',
    'website' => 'https://github.com/makinacorpus/drupal-nodesearch',
    'version' => '1',
    'js' => [
      $path . '/dist/nodesearch.js' => [],
    ],
    'css' => [
      $path . '/dist/nodesearch.css' => [],
    ],
  ];

  if ($embedReact) {
    $libraries['nodesearch']['dependencies'][] = ['nodesearch', 'react'];
  }

  return $libraries;
}

/**
 * Testing handler.
 */
function nodesearch_page_test_form($form, &$form_state) {
  // Randomly select default nodes
  $idList = db_select('node', 'n')
    ->fields('n', ['nid'])
    ->addTag('node_access')
    ->orderRandom()
    ->range(0, rand(2, 5))
    ->execute()
    ->fetchCol()
  ;

  $form['my_nodes'] = [
    '#title'          => t("Choose a node"),
    '#type'           => 'nodesearch',
    '#default_value'  => $idList,
    '#required'       => true,
    '#multiple'       => true,
    '#min'            => 2,
    '#max'            => 6,
    '#bundles'        => 'page',
  ];

  $form['submit'] = [
    '#type'   => 'submit',
    '#submit' => ['nodesearch_page_test_form_submit'],
    '#value'  => t("Select this node and be happy"),
  ];

  return $form;
}

/**
 * Testing form submit handler.
 */
function nodesearch_page_test_form_submit($form, &$form_state) {
  $idList = $form_state['values']['my_nodes'];
  if ($idList) {
    $text = [];
    foreach (node_load_multiple($idList) as $node) {
      $text[] = $node->nid . ' - ' . $node->title;
    }
    drupal_set_message(t("Selected values are:<ul><li>!items</li></ul>", ['!items' => implode('</li><li>', $text)]));
  } else {
    drupal_set_message(t("You have no selected content."));
  }
}

/**
 * Build result array from node
 *
 * @return string[]
 */
function nodesearch_result($node, bool $withImage = false) : array {
  $types = node_type_get_names();

  return [
    'id'          => $node->nid,
    'title'       => $node->title,
    'status'      => $node->status,
    'created'     => (new \DateTimeImmutable('@'.$node->created))->format(\DateTime::ISO8601),
    'updated'     => (new \DateTimeImmutable('@'.$node->changed))->format(\DateTime::ISO8601),
    'type'        => $node->type,
    'human_type'  => $types[$node->type] ?? $node->type,
    'image'       => $withImage ? nodesearch_find_image($node) : '',
  ];
}

/**
 * Attempt to find a suitable image style automatically
 */
function nodesearch_find_image_style() : string {
  $styles = image_styles();

  // Attempt with the standard profile defaults, most people keep a thumbnail
  // image style somehow. A square one would be better.
  if (isset($styles['thumbnail'])) {
    return 'thumbnail';
  }
  if (isset($styles['medium'])) {
    return 'medim';
  }

  return 'full';
}

/**
 * Find image field for given node type
 */
function nodesearch_find_image_field(string $type) : array {
  $candidates = [];

  if ($config = variable_get('nodesearch_preview_image_field')) {
    if (isset($config[$type])) {
      $candidates = is_array($config[$type]) ? $config[$type] : [$config[$type]];
    }
  }

  // @todo cache result
  if (!$candidates) {
    foreach (field_info_instances('node', $type) as $field_name => $instance) {
      $field = field_info_field($field_name);
      if ('image' === $field['type'] || 'unoderef' === $field['type']) {
        $candidates[] = $field_name;
      }
    }
  }

  return $candidates;
}

/**
 * From the given node, attempt to find an image within and return an absolute
 * usable image
 *
 * @param \stdClass $node
 * @param string $image_style
 *
 * @return null|string
 *   Absolute usable image for display
 */
function nodesearch_find_image($node) : string {
  $image_style = variable_get('nodesearch_preview_image_style', null) ?? nodesearch_find_image_style();

  if (!$candidates = nodesearch_find_image_field($node->type)) {
    return '';
  }

  foreach ($candidates as $candidate) {
    if ($items = field_get_items('node', $node, $candidate)) {

      // 'image' field type.
      if (isset($items[0]['uri'])) {
        return image_style_url($image_style, $items[0]['uri']);
      }

      // 'unoderef' field type: this requires recursivity.
      // @todo
      //   - write a recursivity breaker
      //   - make it faster
      if (isset($items[0]['nid'])) {
        foreach ($items as $item) {
          if ($child = node_load($item['nid'])) {
            if ($result = nodesearch_find_image($child)) {
              return $result;
            }
          }
        }
      }
    }
  }

  return '';
}

/**
 * Probably the only function of this whole module.
 *
 * C'est terriblement moche, mais j'assume assez bien.
 */
function nodesearch_page_endpoint() {
  global $user;

  $userId         = $user->uid;
  $maxLimit       = (int)variable_get('nodesearch_endpoint_limit_max', 100);
  $onlyPublished  = (bool)variable_get('nodesearch_endpoint_published_only', true);
  $prefixWildcard = (bool)variable_get('nodesearch_endpoint_prefix_wildcard_enable', true);
  $limit          = (int)variable_get('nodesearch_endpoint_limit_default', 12);
  $includeImage   = variable_get('nodesearch_endpoint_add_image', true);
  $sortField      = 'updated';
  $sortFieldReal  = null;
  $sortOrder      = 'desc';
  $allowedTypes   = node_type_get_names();
  $page           = 1;

  // Without any types configured, this serves no purpose
  if (!$allowedTypes) {
    return MENU_NOT_FOUND;
  }

  // Create the query, the rest will flow along.
  $query = db_select('node', 'n');
  $query->fields('n', ['nid', 'title', 'status', 'created', 'changed', 'type']);
  $query->addTag('node_access');

  // Allow other modules to compete with us (contextual filtering, etc...).
  $query->addTag('nodesearch');

  if (isset($_GET['limit'])) {
    if (!is_numeric($_GET['limit']) || $_GET['limit'] < 1 || $maxLimit < $_GET['limit']) {
      return MENU_NOT_FOUND;
    }
    $limit = (int)$_GET['limit'];
  }

  if (isset($_GET['type'])) {
    if (is_array($_GET['type'])) {
      $types = $_GET['type'];
    } else {
      // Allow coma-separated values
      $types = explode(',', $_GET['type']);
    }
    // Clean things up a little bit
    $types = array_filter($types);
    if ($types) {
      $types = array_map('trim', $types);
      foreach ($types as $type) {
        if (!isset($allowedTypes[$type])) {
          return MENU_NOT_FOUND;
        }
      }
      $query->condition('n.type', $types);
    }
  }

  if (isset($_GET['page'])) {
    // Page starts with 1, not with 0, I hate Drupal.
    if (!is_numeric($_GET['page']) || $_GET['page'] < 1) {
      return MENU_NOT_FOUND;
    }
    $page = (int)$_GET['page'];
  }

  if (isset($_GET['status'])) {
    // No serious filtering on this one, it's a boolean anyway
    $query->condition((int)(bool)$_GET['status']);
  } else if ($onlyPublished) {
    $query->condition('n.status', 1);
  }

  if (isset($_GET['search'])) {
    if (!is_string($_GET['search'])) {
      return MENU_NOT_FOUND;
    }
    $rawSearchString = trim($_GET['search']);
    if ($rawSearchString) {
      // As of now, only title search is allowed
      if ($prefixWildcard) {
        $query->condition('n.title', '%'.db_like($rawSearchString).'%', 'like');
      } else {
        $query->condition('n.title', db_like($rawSearchString).'%', 'like');
      }
    }
  }

  // Order by view history
  if ($userId) {
    $query->leftJoin('history', 'h', "h.nid = n.nid AND h.uid = :history_uid", [':history_uid' => $userId]);
  } else {
    $query->leftJoin('history', 'h', "h.nid = n.nid AND 1 = 0");
  }

  // Allow a boolean field "my content only".
  if ($userId) {
    if (isset($_GET['user_touched'])) {
      $revisionExists = db_select('node_revision', 'r')
        ->condition('r.uid', $query->has('revision_user_id'))
        ->where("r.nid = n.nid")
        ->range(0, 1)
      ;
      $revisionExists->addExpression('1');
      $query->exists($revisionExists);
    }
    if (isset($_GET['user_created'])) {
      $query->condition('n.uid', $userId);
    }
  }

  // Deal with sorting
  $sortField = $_GET['sort_field'] ?? $sortField;
  switch ($sortField) {
    case 'title':
      $sortFieldReal = 'n.title';
      break;
    case 'updated':
      $sortFieldReal = 'n.changed';
      break;
    case 'created':
      $sortFieldReal = 'n.created';
      break;
    case 'status':
      $sortFieldReal = 'n.status';
      break;
    case 'user_viewed':
      $sortFieldReal = 'h.timestamp';
      break;
    case 'user_touched':
      $sortFieldReal = 'r.timestamp';
      break;
    default:
      return MENU_NOT_FOUND;
  }
  if (isset($_GET['sort_order'])) {
    if ('desc' !== $_GET['sort_order'] && 'asc' !== $_GET['sort_order']) {
      return MENU_NOT_FOUND;
    }
    $sortOrder = $_GET['sort_order'];
  }

  // Count query before sort, seems legit, give the front a range to play with.
  $countQuery = $query->countQuery();
  $total = (int)$countQuery->execute()->fetchField();
  $result = [];

  if ($total) {
    // @todo Oh yes please, add a NULLS FIRST | LAST at the right place.
    $query->orderBy($sortFieldReal, $sortOrder);

    // Always end ordering by a default to make result predictible
    $query->orderBy('n.nid', $sortOrder);

    // If page is higher than max page, then reset the current page.
    $maxPage = ceil($total / $limit);
    $page = max([1, min([$maxPage, $page])]);
    $query->range(($page - 1) * $limit, $limit);

    // That should do it.
    if ($includeImage) {
      $nidList = $query->execute()->fetchCol();
      if ($nidList) {
        foreach (node_load_multiple($nidList) as $node) {
          $result[] = nodesearch_result($node, $includeImage);
        }
      }
    } else {
      foreach ($query->execute() as $row) {
        $result[] = nodesearch_result($row);
      }
    }
  } else {
    $page = 1;
  }

  drupal_json_output([
    'page'        => $page,
    'limit'       => $limit,
    'total'       => $total,
    'sort_field'  => $sortField,
    'sort_order'  => $sortOrder,
    'result'      => $result,
  ]);
}
